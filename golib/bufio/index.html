<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Bufio :: Marco Epsilon</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="bufio Overview bufio实现了带缓冲的io操作,提供了对io.Reader,io.Write封装对象Reader,Writer,不仅实现了这些接口,而"/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://marcoepsilon.github.io/golib/bufio/" />


<link rel="stylesheet" href="https://marcoepsilon.github.io/assets/style.css">

  <link rel="stylesheet" href="https://marcoepsilon.github.io/assets/green.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://marcoepsilon.github.io/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="https://marcoepsilon.github.io/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Bufio :: Marco Epsilon — " />
<meta name="twitter:description" content="bufio Overview bufio实现了带缓冲的io操作,提供了对io.Reader,io.Write封装对象Reader,Writer,不仅实现了这些接口,而" />
<meta name="twitter:site" content="https://marcoepsilon.github.io/" />
<meta name="twitter:creator" content="Marco Epsilon" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Bufio :: Marco Epsilon — ">
<meta property="og:description" content="bufio Overview bufio实现了带缓冲的io操作,提供了对io.Reader,io.Write封装对象Reader,Writer,不仅实现了这些接口,而" />
<meta property="og:url" content="https://marcoepsilon.github.io/golib/bufio/" />
<meta property="og:site_name" content="Bufio" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-09-16 22:48:20 &#43;0800 CST" />










<script type="text/javascript" src="/particles/particles.min.js">

</script>
<div style="position:fixed; width:100%; height:100%; " id="marcoEpsilon-Bg"></div>
<div style="position:fixed; width:100%; height:100%; " id="marcoEpsilon-Bg-Second"></div>
<script type="text/javascript" src="/particles/app.js">

</script>

</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Marco Epsilon&#39;s Terminal
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    
<style>
  .nav-guide {
    background-color:chocolate;;;
    width:70px;
    height:40px;
    text-align: center;
    vertical-align: middle;
    cursor:pointer;
  }
  .nav-guide:hover {
    background-color:darkcyan;
  }
  .nav-guide a {
    line-height: 40px;
    text-decoration: none;
    color:white;
  }
  .library-nav {
    list-style-type:none;
    margin:0px;
    display: none;
  }
  .library-item-name {
    line-height:40px;
  }
  .library-nav li {
    background-color:darkslategray;
    width:70px;
    height:40px;
    text-align:left;
    padding-left:10px;
    padding-right:10px;
    z-index:300;
  }
  .library-sub-item {
    line-height:40px;
  }
  li.nav-guide.library-nav-guide:hover ul {
    display: block;
  }
</style>
<nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          
            <li class="nav-guide"><a  href="/about">关于</a></li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/tools">工具</a></li>
          
        
      
        
          
            <li class="nav-guide library-nav-guide">
                <span class="library-item-name">库</span>
                
                  <ul class="library-nav">
                    
                      <li>
                        <a href="https://marcoepsilon.github.io/golib" class="library-sub-item">
                          Go
                        </a>
                      </li>
                    
                      <li>
                        <a href="https://marcoepsilon.github.io/rustlib" class="library-sub-item">
                          Rust
                        </a>
                      </li>
                    
                  </ul>
                
            </li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/photos">照片</a></li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/life">生活</a></li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/">首页</a></li>
          
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">关于</a></li>
      
    
      
        <li><a href="/tools">工具</a></li>
      
    
      
        <li><a href="/golib">库</a></li>
      
    
      
        <li><a href="/photos">照片</a></li>
      
    
      
        <li><a href="/life">生活</a></li>
      
    
      
        <li><a href="/">首页</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://marcoepsilon.github.io/golib/bufio/">Bufio</a></h1>
  <div class="post-meta">
      
    <span class="post-date">
      2019-09-16
    </span>
    
    
    <span class="post-author">::
      Marco Epsilon
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://marcoepsilon.github.io/tags/golang/">golang</a>&nbsp;
    
    #<a href="https://marcoepsilon.github.io/tags/library/">library</a>&nbsp;
    
    #<a href="https://marcoepsilon.github.io/tags/bufio/">bufio</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    





<h1 id="bufio-overview">bufio Overview</h1>

<span style="color:#FF8247; " class="plain_text plain_text_default">
    
bufio实现了带缓冲的io操作,提供了对io.Reader,io.Write封装对象Reader,Writer,不仅实现了这些接口,而且提供了缓冲和一些文本的I/O辅助函数

</span>

<h1 id="常量-constants">常量(Constants)</h1>

<span style="color:#FF8247; " class="plain_text plain_text_default">
    
<br/>
<pre><code class="language-go">const (
    // 缓冲一个token的最大分配大小
    // 除非用户为Scanner.Buffer提供显式缓冲区
    // 实际上缓冲区的最大大小可能比MaxScanTokenSize小
    // 可能需要包括,比如newline
    MaxScanTokenSize = 64 * 1024
)
</code></pre>

</span>

<h1 id="变量-variables">变量(Variables)</h1>

<span style="color:#FF8247; " class="plain_text plain_text_default">
    
<br/>
<pre><code class="language-go">var (
    ErrInvalidUnreadByte = errors.New(&quot;bufio: invalid use of UnreadByte&quot;)
    ErrInvalidUnreadRune = errors.New(&quot;bufio: invalid use of UnreadRune&quot;)
    ErrBufferFull = errors.New(&quot;bufio: buffer full&quot;)
    ErrNegativeCount = errors.New(&quot;bufio: negative count&quot;)
)
</code></pre>
<span style="color:#FF8247; " class="plain_text plain_text_default">
    
由Scanner返回的错误

</span>
<br/>
<pre><code class="language-go">var (
    ErrTooLong = errors.New(&quot;&quot;)
    ErrNegativeAdvance = errors.New(&quot;bufio.Scanner: SplitFunc return negative advance count&quot;)
    ErrAdvanceTooFar = errors.New(&quot;bufio.Scanner: SplitFunc return advance count beyond input&quot;)
)
</code></pre>
<span style="color:#FF8247; " class="plain_text plain_text_default">
    
ErrFinalToken是一个特殊的哨兵错误值,用于指示这应该是Split最后一次传入token,扫描应该停止,ErrFinalToken被Scan接收后,扫描会无错误的返回,这个值对于过早的返回或者必须最后递送一个空token是很有用的,通过自定义error同样也可以实现同样的功能,但是在这提供一个更简洁

</span>

</span>

<h1 id="functions">Functions</h1>

<span style="color:#FF8247; " class="plain_text plain_text_default">
    
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)

</p>
ScanBytes是一个Scanner的分割函数,用于将每个byte作为token返回
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
fucn ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)

</p>
ScanLines是Scanner的一个分割函数,用于返回每一行的文本(剥离行尾标记),行尾标记是一个可选的回车符和一个换行符,最后一个非空文本会被返回,即使没有换行符
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)

</p>
ScanRunes是Scanner的一个分割函数,用于返回分割的Rune,如果出现Rune编码错误,将会把其返回替换为U+FFFD = "\xef\xbf\xbd",由于Scan接口的原因,如果扫描过程中出现错误,客户端无法区别是由编码错误被替换的,还是正确编码产生的
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)

</p>
ScanWords是Scanner的一个分割函数,返回由空格分割的文本,它从不返回空字符串,关于空格的定义采用的是unicode.IsSpace

</span>

<h1 id="readwriter">ReadWriter</h1>

<span style="color:#FF8247; " class="plain_text plain_text_default">
    
ReadWriter是存储了Reader和Writer指针的结构体,它实现了io.Reader和io.Writer接口
<br/>
<pre><code class="language-go">type ReadWriter struct {
    *Reader
    *Writer
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func NewReadWriter(r *Reader, w *Writer) *ReadWriter

</p>
NewReadWriter分配了一个ReadWriter分发给r和w

</span>

<h1 id="reader">Reader</h1>

<span style="color:#FF8247; " class="plain_text plain_text_default">
    
Reader实现了可缓冲的io.Reader
<br/>
<pre><code class="language-go">type Reader struct {
    // contains filtered or unexported fields
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func NewReader(rd io.Reader) *Reader

</p>
返回一个具有默认大小缓冲区新Reader
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func NewReaderSize(rd io.Reader, size int) *Reader

</p>
返回缓冲区至少具有指定大小的新Reader,如果rd已经具有足够的大小,那么将会返回底层的Reader
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) Buffered() int

</p>
返回目前缓冲区可读的字节大小
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) Discard(n int) (discard int, err error)

</p>
Discard废弃接下来的n个字节,如果 0 <= n <= r.Buffered(),且不读取底层Reader,那么函数将保证成功
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) Peek(n int) ([]byte, error)

</p>
Peek在不偏移Reader的情况下,返回接下来的n个字节,如果返回少于n个字节,将会返回错误,如果n太大,将会返回ErrBufferFull
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) Read(p []byte) (n int, err error)

</p>
Read读取数据到p
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) ReadByte() (byte, error)

</p>
读取并返回一个byte,如果没有byte可提供,将会返回错误
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) ReadBytes(delim byte) ([]byte, error)

</p>
ReadBytes读取输入直到第一次出现delim,并返回读取的数据(包括delim),如果读取过程中出现错误(通常是io.EOF),将会返回读取到的数据和错误
<br/>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;bufio&quot;
	&quot;strings&quot;
)

func main() {
	r := strings.NewReader(&quot;hello, bufio readbytes function&quot;)
	b := bufio.NewReader(r)
	data, err := b.ReadBytes('s')
	if err != nil {
		panic(err)
	}
	fmt.Println(string(data))
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (*Reader) ReadLine() (line []byte, isPrefix bool, err error)

</p>
ReadLine是底层读取一行的原语,大多调用者应该调用ReadBytes('\n'),ReadString("\n")或者使用Scanner
ReadLine试图返回一行,不包括结尾的换行符,如果行太长,将会返回行开始且设置isPrefix,剩下的将会在以后返回,最后一次会将isPrefix设为false,buffer只会有效直到下次调用ReadLine,ReadLine返回non-nil line或者 non-nil error,不会同时存在,返回的字节不会包括"\n"或者"\r\n",如果文本结尾没有换行符,不会有错误和指示
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) ReadRune() (r rune, size int, err error)

</p>
ReadRune读取一个Rune并返回其size,如果读取的Rune不合理,它消费一个byte并返回unicode.ReplaceChar(U+FFFD)和size为1
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (*Reader) ReadSlice(delim byte) (line []byte, err error)

</p>
ReadSlice读取直到第一次出现delim,返回buffer的指针,在下次读取之前都保持有效,如果ReadSlice查找delim中出现错误,它将返回buffer里所有数据和错误(通常是io.EOF),如果buffer已经满了还没找到delim,将会返回ErrBufferFull,因为该函数返回的数据将会在下次调用被重写,大多数用户应该使用ReadBytes或ReadString,ReadSlice返回错误仅当line没有以delim结尾
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (*Reader) ReadString(delim byte) string 

</p>
ReadString读取数据知道第一次出现delim,数据中包含delim,如果在寻找delim过程中出现错误，将会返回读取到的数据和错误(通常是io.EOF),ReadString返回err != nil当且仅当数据不以delim结尾
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) Reset(r io.Reader)

</p>
Reset丢弃缓冲中的数据,并且将底层的Reader置换为r
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) Size() int

</p>
返回底层buffer使用的大小
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) UnreadByte() error

</p>
unread最近的byte,只有最近读取的byte才能被unread,UnreadByte调用后只能调用read函数才能再次调用,Peek不属于读操作
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) UnreadRune() error

</p>
unread最近的rune,只有再次调用ReadRune才能再次被调用,否则发生错误(严格于UnreadByte)
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Reader) WriteTo(w io.Writer) (n int64, err error)

</p>
实现WriteTo接口,可能会多次调用底层Reader的Read,如果底层Reader实现了WriteTo,将不会利用缓冲直接调用底层Reader的WriteTo

</span>

<h1 id="scanner">Scanner</h1>

<span style="color:#FF8247; " class="plain_text plain_text_default">
    
Scanner用于提供读取的接口读取数据比如由换行分割的文本,成功的调用Scan逐步浏览'token',跳过标记之间的bytes,明确地的'token'是由type SplitFunc定义,默认的分割函数是由行分割,包中定义的分割函数用于扫描行(line),字节(bytes),UTF-8 encode runes,space-delimited-word,用户可能使用自定义函数代替,扫描停止在EOF,first-error,token对于buffer太大,是不可恢复的,当扫描停止时,底层的Reader可能离上个token任意距离,扫描过程中需要更多处理应该使用bufio.Reader完成
<br/>
<pre><code class="language-go">type Scanner struct {
    // contains filtered or unexported fields
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func NewScanner(r io.Reader) *Scanner

</p>
返回一个从r读取的新Scanner,默认分割函数是SplitLines
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (*Scanner) Buffer(buf []byte, max int)

</p>
Buffer设置初始化的buffer,以及扫描过程中可能分配的最大缓冲区大小,最大的token大小是max和cap(buf)中的最大者,如果max <=cap(buf),扫描过程中将不会分配内存
默认情况下,Buffer使用内部缓冲区,且设置最大token大小为MaxScanTokenSize
扫描已经开始,Buffer可能会panic
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (s *Scanner) Bytes() []byte

</p>
Bytes返回最近扫描产生的token,使用内部缓冲区返回
<br/>
<pre><code class="language-go">package main
import (
	&quot;fmt&quot;
	&quot;bufio&quot;
	&quot;strings&quot;
)

func main() {
	r := strings.NewReader(&quot;hello, i will call you\ncan you fell me?&quot;)
	br := bufio.NewScanner(r)
	_ = br.Scan()
	data := br.Bytes()
	fmt.Println(string(data))
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (*Scanner) Err() error

</p>
返回扫描过程中出现的non-EOF error
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (*Scanner) Scan() bool

</p>
Scan推动Scanner到next token,如果扫描停止将会返回false,除了遇到io.EOF错误,其他错误将会在Err方法中返回non-nil错误,Scan将会panic,如果调用返回太多empty token由于Scanner没有前进,这是所有Scanner的共同模式
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (s *Scanner) Split(split SplitFunc)

</p>
Split设置扫描过程中的分割函数,默认分割函数是ScanLines
如果在扫描已经开始设置Split函数,将会panic
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (s *Scanner) Text() string

</p>
返回最近新分配的string拥有扫描生成的token的bytes
<br/>
<pre><code class="language-go">// scanner.go
package main
import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;bufio&quot;
)

func main() {
	fileEntry, err := os.Open(&quot;scanner.go&quot;)
	if err != nil {
		panic(err)
	}
	br := bufio.NewScanner(fileEntry)
	// delim by newline
	lineCount := 0
	for br.Scan() {
		fmt.Println(br.Text())
		lineCount++
	}
	if err := br.Err(); err != nil {
		fmt.Println(err)
	}
	fmt.Printf(&quot;file occur %d lines\n&quot;, lineCount)
	defer fileEntry.Close()
}
</code></pre>

</span>

<h1 id="splitfunc">SplitFunc</h1>

<span style="color:#FF8247; " class="plain_text plain_text_default">
    
SplitFunc是标志化输入的分割函数签名,参数是剩余未处理初始字符串和atEOF标志,返回值是next token前进的字节数和可能出现的错误,Scan停止当出现错误,可能会造成数据被丢弃
除非atEOF是true否则永远不会由empty slice调用,如果atEOF是true,则返回的非空数据可能包含未处理的文本
<br/>
<pre><code class="language-go">// words count
package main
import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;os&quot;
)

func main() {
	text := &quot;int int32 int64 uint uint32 uint64 float32 float64 ...&quot;
	r := strings.NewReader(text)
	br := bufio.NewScanner(r)
	br.Split(bufio.ScanWords)
	wordCount := 0
	for br.Scan() {
		wordCount++
	}
	if err := br.Err(); err != nil {
		fmt.Fprintf(os.Stderr, &quot;scan error: %s\n&quot;, err)
	}
	fmt.Printf(&quot;word occur count: %d\n&quot;, wordCount)
}
</code></pre>
<br/>
<h1 id="custom-split-func">Custom Split Func</h1>

<pre><code class="language-go">package main
import (
	&quot;bufio&quot;
	&quot;strings&quot;
	&quot;fmt&quot;
	&quot;strconv&quot;
	&quot;os&quot;
)
// 自定义分割函数,用于检查输入是否是合理的32bit数字
func main() {
	text := &quot;123 456 7869 12345679012901290&quot;
	split := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
		advance, token, err = bufio.ScanWords(data, atEOF)
		if err == nil &amp;&amp; token != nil {
			_, err = strconv.ParseInt(string(token), 10, 32)
		}
		return
	}
	br := bufio.NewScanner(strings.NewReader(text))
	br.Split(split)
	for br.Scan() {
		fmt.Println(br.Text())
	}
	if err := br.Err(); err != nil {
		fmt.Fprintf(os.Stderr, &quot;error: %s\n&quot;, err)
	}
}
</code></pre>
<br/>
<pre><code class="language-go">package main
import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;os&quot;
)

func main() {
	br := bufio.NewScanner(strings.NewReader(&quot;1,2,3,4&quot;))
	split := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
		for i := 0; i &lt; len(data); i++ {
			if data[i] == ',' {
				return i + 1, data[:i], nil
			}
		}
		// !atEOF 不读完
		if !atEOF {
			return 0, nil, nil
		}
		// atEOF 读完 but not end in ','
		return 0, data, bufio.ErrFinalToken
	}
	br.Split(split)
	for br.Scan() {
		fmt.Println(br.Text())
	}
	if err := br.Err(); err != nil {
		fmt.Fprintf(os.Stderr, &quot;error: %s\n&quot;, err)
	}
}
</code></pre>

</span>

<h1 id="writer">Writer</h1>

<span style="color:#FF8247; " class="plain_text plain_text_default">
    
Writer为io.Writer对象实现了缓冲,如果写入Writer发生错误,没有数据将会被接收,后续写入,Flush,将会返回错误,在所有数据写入之后,调用者确保调用Flush,将输入输出到底层Writer
<br/>
<pre><code class="language-go">type Writer struct {
    // contains filtered or unexported fields
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func NewWriter(w io.Writer) *Writer

</p>
返回一个带有默认buffer的新Writer
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func NewWriterSize(w io.Writer, size int) (*Writer)

</p>
返回缓冲区至少为size的Writer,如果底层Writer已经有足够的缓冲区,将会返回底层Writer
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Writer) Available() int

</p>
返回缓冲区未使用的字节数
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Writer) Flush() error

</p>
刷新数据到底层的Writer
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)

</p>
实现了io.ReadFrom接口,如果底层实现了io.ReadFrom接口,那么将会使用底层Writer(无论是否有缓冲)
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Writer) Reset(w *Writer)

</p>
丢弃缓冲中数据,清除错误,将底层Writer设置为w
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Writer) Size() int

</p>
返回底层buffer使用的大小
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Writer) Write(p []byte) (n int, err error)

</p>
将会p中数据写入buffer,如果n < len(p),会返回错误解释写入较短的原因
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Writer) WriteByte(c byte) error

</p>
WriteByte写入单个byte
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Writer) WriteRune(r rune) (size int, err error)

</p>
写入rune,返回大小和错误
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Writer) WriteString(s string) (int, error)

</p>
写入字符串,返回写入的字节,如果写入小于len(s),返回错误解释原因

</span>

  </div>
  
  <div style="margin-top:0px;" class="pagination">
    <div style="margin-top:10px;" class="pagination__title">
      <span
        class="pagination__title-h">Next Post</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="https://marcoepsilon.github.io/golib/encoding/binary/">
          <span class="button__icon">←</span>
          <span class="button__text">Binary</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="https://marcoepsilon.github.io/golib/os/">
          <span class="button__text">Os</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

<script src="https://utteranc.es/client.js"
        repo="MarcoEpsilon/marcoepsilon.github.io"
        issue-term="og:title"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script>
</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Marco Epsilon@Copyright</div>
    
  </div>
</footer>
<link rel="stylesheet" type="text/css" href="/assets/prism.css" />
<script src="https://marcoepsilon.github.io/assets/main.js"></script>
<script src="https://marcoepsilon.github.io/assets/prism.js"></script>



<div style="">
    <p style="width:100%; padding-left:25%; color:brown; font-size:23px;">
        我只知道一件事情
    </p>
    <p style="width:100%; padding-left:48%; color:coral; font-size:23px;">我什么都不知道</p>
</div>


  
</div>

</body>
</html>
