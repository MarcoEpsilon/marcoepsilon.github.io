<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Strings :: Marco Epsilon</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Overview strings包提供了简单的函数操作UTF-8编码的字符串 Functions func Compare(a, b string) int 以字典序比较两个字符串并返回结果,如果结果大于0,说明a大于b,结果"/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://marcoepsilon.github.io/golib/strings/" />


<link rel="stylesheet" href="https://marcoepsilon.github.io/assets/style.css">

  <link rel="stylesheet" href="https://marcoepsilon.github.io/assets/green.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://marcoepsilon.github.io/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="https://marcoepsilon.github.io/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Strings :: Marco Epsilon — " />
<meta name="twitter:description" content="Overview strings包提供了简单的函数操作UTF-8编码的字符串 Functions func Compare(a, b string) int 以字典序比较两个字符串并返回结果,如果结果大于0,说明a大于b,结果" />
<meta name="twitter:site" content="https://marcoepsilon.github.io/" />
<meta name="twitter:creator" content="Marco Epsilon" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Strings :: Marco Epsilon — ">
<meta property="og:description" content="Overview strings包提供了简单的函数操作UTF-8编码的字符串 Functions func Compare(a, b string) int 以字典序比较两个字符串并返回结果,如果结果大于0,说明a大于b,结果" />
<meta property="og:url" content="https://marcoepsilon.github.io/golib/strings/" />
<meta property="og:site_name" content="Strings" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-09-20 22:50:47 &#43;0800 CST" />










<script type="text/javascript" src="/particles/particles.min.js">

</script>
<div style="position:fixed; width:100%; height:100%; " id="marcoEpsilon-Bg"></div>
<div style="position:fixed; width:100%; height:100%; " id="marcoEpsilon-Bg-Second"></div>
<script type="text/javascript" src="/particles/app.js">

</script>

</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Marco Epsilon&#39;s Terminal
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    
<style>
  .nav-guide {
    background-color:chocolate;;;
    width:70px;
    height:40px;
    text-align: center;
    vertical-align: middle;
    cursor:pointer;
  }
  .nav-guide:hover {
    background-color:darkcyan;
  }
  .nav-guide a {
    line-height: 40px;
    text-decoration: none;
    color:white;
  }
  .library-nav {
    list-style-type:none;
    margin:0px;
    display: none;
  }
  .library-item-name {
    line-height:40px;
  }
  .library-nav li {
    background-color:darkslategray;
    width:70px;
    height:40px;
    text-align:left;
    padding-left:10px;
    padding-right:10px;
    z-index:300;
  }
  .library-sub-item {
    line-height:40px;
  }
  li.nav-guide.library-nav-guide:hover ul {
    display: block;
  }
</style>
<nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          
            <li class="nav-guide"><a  href="/about">关于</a></li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/tools">工具</a></li>
          
        
      
        
          
            <li class="nav-guide library-nav-guide">
                <span class="library-item-name">库</span>
                
                  <ul class="library-nav">
                    
                      <li>
                        <a href="https://marcoepsilon.github.io/golib" class="library-sub-item">
                          Go
                        </a>
                      </li>
                    
                      <li>
                        <a href="https://marcoepsilon.github.io/rustlib" class="library-sub-item">
                          Rust
                        </a>
                      </li>
                    
                  </ul>
                
            </li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/photos">照片</a></li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/life">生活</a></li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/">首页</a></li>
          
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">关于</a></li>
      
    
      
        <li><a href="/tools">工具</a></li>
      
    
      
        <li><a href="/golib">库</a></li>
      
    
      
        <li><a href="/photos">照片</a></li>
      
    
      
        <li><a href="/life">生活</a></li>
      
    
      
        <li><a href="/">首页</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://marcoepsilon.github.io/golib/strings/">Strings</a></h1>
  <div class="post-meta">
      
    <span class="post-date">
      2019-09-20
    </span>
    
    
    <span class="post-author">::
      Marco Epsilon
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://marcoepsilon.github.io/tags/golang/">golang</a>&nbsp;
    
    #<a href="https://marcoepsilon.github.io/tags/library/">library</a>&nbsp;
    
    #<a href="https://marcoepsilon.github.io/tags/strings/">strings</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    





<h1 id="overview">Overview</h1>

<span style="color:#FF7256; " class="plain_text plain_text_default">
    
strings包提供了简单的函数操作UTF-8编码的字符串

</span>

<h1 id="functions">Functions</h1>

<span style="color:#FF7256; " class="plain_text plain_text_default">
    
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Compare(a, b string) int

</p>
以字典序比较两个字符串并返回结果,如果结果大于0,说明a大于b,结果等于0,表明a等于b,结果小于0,表明a小于b
提供此函数是为了和包bytes提供一致性,使用内置的= ><会更快更清晰
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Contains(s, substr string) bool

</p>
判断substr是否是s的子串
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ContainsAny(s, chars string) bool

</p>
判断是否存在任何chars中的Unicode码点存在于s
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ContainsRune(s string, r rune) bool

</p>
判断s中是否存在Unicode码点r
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Count(s, substr string) int

</p>
返回substr非重叠实例在s中出现次数
<br/>
<pre><code class="language-go">package main

import (
	&quot;strings&quot;
	&quot;fmt&quot;
)

func main() {
	text := &quot;hello, world&quot;
	if strings.ContainsAny(text, &quot;w&quot;) {
		fmt.Println(text)
	}
	count := strings.Count(text, &quot;o&quot;)
	fmt.Println(count)
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func EuqalFold(s, t string) bool

</p>
EuqalFold判断s,t以Unicode大小写折叠的情况下,是否相同
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Fields(s string) []string

</p>
Fields分割s每个周围是连续空白字符(由unicode.IsSpace定义)的实例,如果s中只包含空白符,将会返回空切片
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func FiledsFunc(s string, f func(r rune) bool) []string

</p>
FieldsFunc在每个符合f(c)的Unicode码点c处进行分割,并返回其切片,如果s中所有Unicode码点都符合或s为空,将会返回空切片,FieldsFunc不保证调用f(c)的顺序,如果f(c)没有给出一致的结果,FieldsFunc可能会崩溃
<br/>
<pre><code class="language-go">package main
import (
	&quot;strings&quot;
	&quot;fmt&quot;
)

func main() {
	text := &quot;strings bytes strconv bufio&quot;
	words := strings.Fields(text)
	for _, word := range words {
		fmt.Println(word)
	}
	split := func(r rune) bool {
		if string(r) == &quot;s&quot; {
			return true
		}
		return false
	}
	exceptStr := strings.FieldsFunc(text, split)
	for _, except := range exceptStr {
		fmt.Println(except)
	}
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func HasPrefix(s, prefix string) bool

</p>
判断prefix是否是s的前缀
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func HasSuffix(s, suffix string) bool

</p>
判断suffix是否是s的后缀
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Index(s, substr string) int

</p>
返回substr在s中第一次出现的索引,如果不存在返回-1
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func IndexAny(s, chars string) int

</p>
找出chars任何码点在s中第一次出现的索引,如果不存在返回-1
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func IndexByte(s string, c byte) int

</p>
返回c在s中第一次出现的位置,如果不存在,返回-1
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func IndexFunc(s string, f func(r rune) bool) int

</p>
在s中找出第一个符合f(c)的Unicode码点位置,如果不存在返回-1
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func IndexRune(s string, r rune) int

</p>
在s中找出第一个r的位置,如果不存在,返回-1
<br/>
<pre><code class="language-go">package main
import (
	&quot;strings&quot;
	&quot;fmt&quot;
)

func main() {
	text := &quot;hello, world!&quot;
	worldPos := strings.Index(text, &quot;world&quot;)
	if worldPos != -1 {
		fmt.Println(worldPos)
	}
	selectPos := strings.IndexAny(text, &quot;qwbr&quot;)
	if selectPos != -1 {
		fmt.Println(selectPos)
	}
	ctext := &quot;您好,世界!&quot;
	cPos := strings.IndexRune(ctext, '\u4e16')
	if cPos != -1 {
		fmt.Println(cPos)
	}
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Join(a []string, sep string) []string

</p>
Join连接a中的元素为一个字符串,元素之间使用sep连接
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func LastIndex(s, substr string) int

</p>
返回substr在s中最后一次出现的位置,如果不存在,返回-1
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func LastIndexAny(s, chars string) int

</p>
返回chars任意元素在s中最后一次出现的位置,如果不存在,返回-1
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func LastIndexByte(s string, c byte) int

</p>
返回c在s中最后一次出现的位置,如果不存在,返回-1
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func LastIndexFunc(s string, f func(r rune) bool) int

</p>
返回最后一个符合f(c)的c在s中位置,如果不存在,返回-1
<br/>
<pre><code class="language-go">package main
import (
	&quot;strings&quot;
	&quot;fmt&quot;
)

func main() {
	text := &quot;abcbabcdbfe&quot;
	prefix := &quot;abc&quot;
	suffix := &quot;dbfe&quot;
	if strings.HasPrefix(text, prefix) {
		fmt.Println(prefix)
	}
	if strings.HasSuffix(text, suffix) {
		fmt.Println(suffix)
	}
	lastPos := strings.LastIndex(text, prefix)
	if lastPos != -1 {
		fmt.Println(lastPos)
	}
	lastPos = strings.LastIndexAny(text, &quot;bef&quot;)
	if lastPos != -1 {
		fmt.Println(lastPos)
	}
	list := []string{&quot;Marco&quot;, &quot;Epsilon&quot;, &quot;sig&quot;}
	fmt.Println(strings.Join(list, &quot; &quot;))
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Map(mapping func(rune) rune, s string) string

</p>
Map返回通过mapping修改的s副本,如果mapping产生负值,该值将不会被替换
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Repeat(s string, count int) string

</p>
返回一个s连续复制count次的新字符串
如果count为负或(len(s) * count)溢出将会造成panic
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Replace(s, old, new string, count int) string 

</p>
Replace返回前n个s中old被替换为new后s的副本,如果old为空字符串,它匹配每个UTF-8序列的开始,产生k+1替换一个k-rune string,如果n < 0,则会没有限制的替换
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ReplaceAll(s, old, new string)  string

</p>
等价于Replace(s, old, new, -1)
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Split(s, sep string) []string

</p>
按照sep分割s,并返回其分割后产生的列表
如果s中不含sep,且sep非空,函数将会返回一个整个s
如果sep为空,将会在每个UTF-8序列后分割,如果二者皆为空,将会返回空列表
等价于count为-1的SplitN
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func SplitAfter(s, sep string) []string 

</p>
在字符串sep后分割,返回分割后的列表
如果s不含sep且sep非空,将会返回真整个字符串
如果sep为空,则在每个UTF-8序列处分割,如果s和sep都为空,将会返回空切片
等价于count为-1的SplitAfterN
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func SplitAfterN(s, sep string, n int) []string

</p>
在字符串sep后处分割,并返回切片
返回的切片大小与n有关
<br/>
n > 0 最多返回n个子字符串,最后一个子字符串是未分割的
n == 0,不发生分割,返回nil
n < 0,返回所以子字符串
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func SplitN(s, sep string, n int) []string

</p>
和SplitAfterN类似,不过它在sep处分割
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Title(s string) string

</p>
返回所有s中所有Unicode words的Unicode字母映射为Unicode Title的副本
Bug(rsc):对于单词边界为Unicode标点符号Unicode Title不能恰当处理
<br/>
<pre><code class="language-go">package main
import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	text := &quot;hello, world&quot;
	trans := strings.Map(func(r rune) rune {return r + 2}, text)
	fmt.Println(trans)
	split := strings.Split(text, &quot;,&quot;)
	fmt.Printf(&quot;%q\n&quot;, split)
	replaced := strings.Replace(text, &quot;o&quot;, &quot;*&quot;, -1)
	fmt.Println(replaced)
	titled := strings.Title(text)
	fmt.Println(titled)
	splitAfter := strings.SplitAfterN(text, &quot;,&quot;, -1)
	fmt.Printf(&quot;%q\n&quot;, splitAfter)
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ToLower(s string) string

</p>
返回将s转换为小写的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ToLowerSpecial(c unicode.SpecialCase, s string) string

</p>
返回由unicode.SpecialCase映射的Unicode字母的小写副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ToTitle(s string) string

</p>
返回s所有Unicode字母的Title Case的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ToTitleSpecial(c unicode.SpecialCase, s string) string

</p>
返回所有s中所有Unicode字母通过指定c映射的Title Case副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ToUpper(s string) string

</p>
返回s中Unicode字母的大写副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ToUpperSpecial(c unicode.SpecialCase, s string) string

</p>
返回s中所有Unicode字母指定c映射的Upper Case副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func ToValidUTF8(s string, replacement string) string

</p>
返回s中不合理UTF-8字符被replacement替换的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Trim(s, cutset string) string

</p>
Trim返回移除s中前导和后导含有cutset字符的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func TrimFunc(s string, f func(r rune) bool) string

</p>
返回移除前导和后导中含有符合f(c)的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func TrimLeft(s, cutset string) string

</p>
TrimLeft返回移除s中前导含有cutset中Unicode码点的副本
Ps:为了移除前缀,可以使用TrimPrefix
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func TrimLeftFunc(s string, f func(r rune) bool) string

</p>
返回移除前导字符符合f(c)的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func TrimPrefix(s, prefix) string

</p>
返回移除s指定前缀prefix的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func TrimRight(s string, cutset string) string

</p>
返回s后导移除包含cutset字符的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func TrimRightFunc(s string, f func(r rune) bool) string

</p>
返回移除后导字符符合f(c)后的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func TrimSpace(s string) string

</p>
返回移除s两边空白的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func TrimSuffix(s, suffix string) string

</p>
返回s移除后缀suffix的副本
<br/>
<pre><code class="language-go">package main
import (
	&quot;fmt&quot;
	&quot;strings&quot;
)

func main() {
	text := &quot;!-!-hello, world--!&quot;
	trimed := strings.Trim(text, &quot;-!&quot;)
	fmt.Println(trimed)
	trimLeft := strings.TrimLeft(text, &quot;!-&quot;)
	fmt.Println(trimLeft)
	trimRight := strings.TrimRight(text, &quot;!-&quot;)
	fmt.Println(trimRight)
	upper := strings.ToUpper(trimed)
	fmt.Println(upper)
	trimPrefix := strings.TrimPrefix(text, &quot;!-!-&quot;)
	fmt.Println(trimPrefix)
	trimSuffix := strings.TrimSuffix(text, &quot;--!&quot;)
	fmt.Println(trimSuffix)
	text = &quot;   hello, world   &quot;
	trimSpace := strings.TrimSpace(text)
	fmt.Println(trimSpace)
}
</code></pre>

</span>

<h1 id="builder">Builder</h1>

<span style="color:#FF7256; " class="plain_text plain_text_default">
    
Builder通常是更高效的创建字符串使用Write方法,它最大程度上减少了内存复制,零值是准备使用,不要复制一个非零Builder
<br/>
<pre><code class="language-go">type Builder struct {
    // contains filtered or unexported fields
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Builder) Cap() int

</p>
返回底层字节序列的容量,包含所有建立时分配的空间,包括写入的
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Builder) Grow() int

</p>
Grow增加b的容量,如有必要,可以保证另外n个byte的空间,调用至少还可以无需分配的写入n个字节,如果n小于0,则会panic
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Builder) Len() int

</p>
返回积累的字节数b.Len() == len(b.String())
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Builder) Reset() 

</p>
清空b中内容
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Builder) String() string

</p>
String返回积累的字符串
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Builder) Write(p []byte) (n int, err error)

</p>
将p中内容写入b,总是返回len(p),nil
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Builder) WriteByte(c byte) error

</p>
将c写入b,总是返回nil
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Builder) WriteRune(r rune) (int, error)

</p>
写入UTF-8编码的Unicode码点到b,返回写入r的大小和nil error
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (b *Builder) WriteString(s string) (int, error)

</p>
写入s到b,总是返回len(s)和nil error
<br/>
<pre><code class="language-go">package main
import (
	&quot;strings&quot;
	&quot;fmt&quot;
)

func main() {
	var builder strings.Builder
	builder.WriteString(&quot;hello, strings.Builder&quot;)
	fmt.Println(builder.Cap())
	fmt.Println(builder.Len())
	fmt.Println(builder.String())
}
</code></pre>

</span>

<h1 id="reader">Reader</h1>

<span style="color:#FF7256; " class="plain_text plain_text_default">
    
Reader实现了io.Read,io.ReadAt,io.Seeker,io.WriteTo,io.ByteScanner,io.RuneScanner接口,通过读取字符串,对于零值的操作像操作一个空字符串的Reader
<br/>
<pre><code class="language-go">type Reader struct {
    // contains filtered or unexported fields
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func NewReader(s string) *Reader

</p>
NewReader返回一个从s读取的新Reader,它和bytes.NewBufferString相似,但是它更高效且只可读
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) Len() int

</p>
返回未读部分的字节数
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) Read(b []byte) (n int, err error)

</p>
实现的io.Reader接口
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) ReadAt(b []byte, offset int64) (n int, err error)

</p>
实现的ReadAt接口
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) ReadByte() (byte, error)

</p>
实现的io.ByteReader接口
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) ReadRune() (ch rune, size int, err error)

</p>
实现的io.RuneReader接口
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) Reset(s string)

</p>
重新设置Reader从s读取
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) Seek(offset int64, whence int) (int, error)

</p>
Seek实现了io.Seek接口
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) Size() int64

</p>
返回底层string的原始长度
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) UnreadByte() error

</p>
为了实现io.ByteScanner接口
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) UnreadRune() error

</p>
为了实现io.RuneScanner接口
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Reader) WriteTo(w io.Writer) (n int64, err error)

</p>
实现了io.WriteTo接口

</span>

<h1 id="replacer">Replacer</h1>

<span style="color:#FF7256; " class="plain_text plain_text_default">
    
Replacer通过替换品替换列表中字符串,这是并发安全的
<br/>
<pre><code class="language-go">type Replacer struct {
    // contains filtered or unexported fields
}
</code></pre>
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func NewReplacer(oldnew string...) *Replacer

</p>
NewReplacer返回一个新的Replacer由old,new string的列表,替换品按照它们在目标字符里出现的顺序执行,old string以列表的顺序比较
如果给出的参数是奇数的将会panic
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Replace) Replace(s string) string

</p>
返回替代品替换后s的副本
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func (r *Replace) WriteString(w io.Writer, s string) (n int, err error)

</p>
替代品对s中元素替换,并写入w
<br/>
<pre><code class="language-go">package main
import (
	&quot;strings&quot;
	&quot;fmt&quot;
)

func main() {
	replacer := strings.NewReplacer(&quot;sb&quot;, &quot;**&quot;, &quot;cnm&quot;, &quot;***&quot;)
	handled := replacer.Replace(&quot;ni shi sb, cnm&quot;)
	fmt.Println(handled)
}
</code></pre>

</span>

  </div>
  
  <div style="margin-top:0px;" class="pagination">
    <div style="margin-top:10px;" class="pagination__title">
      <span
        class="pagination__title-h">Next Post</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="https://marcoepsilon.github.io/golib/net/net/">
          <span class="button__icon">←</span>
          <span class="button__text">Net</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="https://marcoepsilon.github.io/golib/encoding/binary/">
          <span class="button__text">Binary</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

<script src="https://utteranc.es/client.js"
        repo="MarcoEpsilon/marcoepsilon.github.io"
        issue-term="og:title"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script>
</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Marco Epsilon@Copyright</div>
    
  </div>
</footer>
<link rel="stylesheet" type="text/css" href="/assets/prism.css" />
<script src="https://marcoepsilon.github.io/assets/main.js"></script>
<script src="https://marcoepsilon.github.io/assets/prism.js"></script>



<div style="">
    <p style="width:100%; padding-left:25%; color:brown; font-size:23px;">
        我只知道一件事情
    </p>
    <p style="width:100%; padding-left:48%; color:coral; font-size:23px;">我什么都不知道</p>
</div>


  
</div>

</body>
</html>
