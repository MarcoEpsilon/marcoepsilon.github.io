<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Unsafe :: Marco Epsilon</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Overview unsafe包含了绕过go类型安全的方法,导入unsafe包可能是不可移植的. type ArbitraryType type ArbitraryType int ArbitraryType在包中的目的仅仅是为了文"/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://marcoepsilon.github.io/golib/unsafe/" />


<link rel="stylesheet" href="https://marcoepsilon.github.io/assets/style.css">

  <link rel="stylesheet" href="https://marcoepsilon.github.io/assets/green.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://marcoepsilon.github.io/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="https://marcoepsilon.github.io/favicon/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Unsafe :: Marco Epsilon — " />
<meta name="twitter:description" content="Overview unsafe包含了绕过go类型安全的方法,导入unsafe包可能是不可移植的. type ArbitraryType type ArbitraryType int ArbitraryType在包中的目的仅仅是为了文" />
<meta name="twitter:site" content="https://marcoepsilon.github.io/" />
<meta name="twitter:creator" content="Marco Epsilon" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Unsafe :: Marco Epsilon — ">
<meta property="og:description" content="Overview unsafe包含了绕过go类型安全的方法,导入unsafe包可能是不可移植的. type ArbitraryType type ArbitraryType int ArbitraryType在包中的目的仅仅是为了文" />
<meta property="og:url" content="https://marcoepsilon.github.io/golib/unsafe/" />
<meta property="og:site_name" content="Unsafe" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-11-09 23:03:46 &#43;0800 CST" />










<script type="text/javascript" src="/particles/particles.min.js">

</script>
<div style="position:fixed; width:100%; height:100%; " id="marcoEpsilon-Bg"></div>
<div style="position:fixed; width:100%; height:100%; " id="marcoEpsilon-Bg-Second"></div>
<script type="text/javascript" src="/particles/app.js">

</script>

</head>
<body class="">


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Marco Epsilon&#39;s Terminal
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    
<style>
  .nav-guide {
    background-color:chocolate;;;
    width:70px;
    height:40px;
    text-align: center;
    vertical-align: middle;
    cursor:pointer;
  }
  .nav-guide:hover {
    background-color:darkcyan;
  }
  .nav-guide a {
    line-height: 40px;
    text-decoration: none;
    color:white;
  }
  .library-nav {
    list-style-type:none;
    margin:0px;
    display: none;
  }
  .library-item-name {
    line-height:40px;
  }
  .library-nav li {
    background-color:darkslategray;
    width:70px;
    height:40px;
    text-align:left;
    padding-left:10px;
    padding-right:10px;
    z-index:300;
  }
  .library-sub-item {
    line-height:40px;
  }
  li.nav-guide.library-nav-guide:hover ul {
    display: block;
  }
</style>
<nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          
            <li class="nav-guide"><a  href="/about">关于</a></li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/tools">工具</a></li>
          
        
      
        
          
            <li class="nav-guide library-nav-guide">
                <span class="library-item-name">库</span>
                
                  <ul class="library-nav">
                    
                      <li>
                        <a href="https://marcoepsilon.github.io/golib" class="library-sub-item">
                          Go
                        </a>
                      </li>
                    
                      <li>
                        <a href="https://marcoepsilon.github.io/rustlib" class="library-sub-item">
                          Rust
                        </a>
                      </li>
                    
                  </ul>
                
            </li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/photos">照片</a></li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/life">生活</a></li>
          
        
      
        
          
            <li class="nav-guide"><a  href="/">首页</a></li>
          
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">关于</a></li>
      
    
      
        <li><a href="/tools">工具</a></li>
      
    
      
        <li><a href="/golib">库</a></li>
      
    
      
        <li><a href="/photos">照片</a></li>
      
    
      
        <li><a href="/life">生活</a></li>
      
    
      
        <li><a href="/">首页</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://marcoepsilon.github.io/golib/unsafe/">Unsafe</a></h1>
  <div class="post-meta">
      
    <span class="post-date">
      2019-11-09
    </span>
    
    
    <span class="post-author">::
      Marco Epsilon
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://marcoepsilon.github.io/tags/golang/">golang</a>&nbsp;
    
    #<a href="https://marcoepsilon.github.io/tags/library/">library</a>&nbsp;
    
    #<a href="https://marcoepsilon.github.io/tags/unsafe/">unsafe</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    





<h1 id="overview">Overview</h1>

<span style="color:#26CD88; " class="plain_text plain_text_default">
    
unsafe包含了绕过go类型安全的方法,导入unsafe包可能是不可移植的.

</span>

<h1 id="type-arbitrarytype">type ArbitraryType</h1>

<span style="color:#26CD88; " class="plain_text plain_text_default">
    
<br/>
<pre><code class="language-go">type ArbitraryType int
</code></pre>

<p>ArbitraryType在包中的目的仅仅是为了文档化且实际上不是unsafe包中的一部分,它展示了Go中任意表达式的类型.</p>


</span>

<h1 id="functions">Functions</h1>

<span style="color:#26CD88; " class="plain_text plain_text_default">
    
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Alignof(x ArbitraryType) uintptr

</p>
AlignOf取出任意表达式x的类型,并返回假设变量v的对齐方式,就像v是通过var v = x声明的一样.它的最大值为m,因此v的地址始终为零mod m,和reflect.TypeOf(x).Align()返回的值相同,在一种特别的情况下,如果一个变量s是结构体,f是该结构体的字段,AlignOf(s.f)返回结构体字段要求的对齐方式,这种情况和reflect.TypeOf(s).FieldAlign()相同,AlignOf返回值是Go的常量.
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Offsetof(x ArbitraryType) uintptr

</p>
OffsetOf返回x中结构体字段的偏移,那个必须是structValue.field的形式,此外,它返回结构体起始到字段起始的字节数,OffsetOf的返回值是Go的常量.
<p style="background-color:rgba(143,188,143,0.2); width:100%; color:#FFA500; border-radius: 10px; font-size:16px; padding:0.2rem 0; text-indent:1em; word-wrap:break-word;">
    
func Sizeof(x ArbitraryType) uintptr

</p>
SizeOf取出x的任意类型,并返回其假设变量v像通过var v = x声明的字节数,大小不包含任何可能被x引用的内存,比如x是切片,SizeOf返回slice描述符的大小,而不是其引用的内存,SizeOf返回值是Go的常量.

</span>

<h1 id="type-pointer">type Pointer</h1>

<span style="color:#26CD88; " class="plain_text plain_text_default">
    
<br/>
<pre><code class="language-go">type Pointer *ArbitraryType
</code></pre>
Pointer表示任意类型的指针,有四种操作对于Pointer类型提供而其他类型不提供的.
<div style="padding-left:2.5rem; color:#FF82AB;">
    
    
<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
    任何类型值的指针都可以被转换为Pointer
    
    </span>
</p>
    
<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
    Pointer能够被转换为任何类型的指针值
    
    </span>
</p>
    
<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
    uintptr能够被转化为Pointer
    
    </span>
</p>
    
<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
    Pointer能够被转换为uintptr
    
    </span>
</p>

</div>

Pointer因此允许击败类型系统并且读和写任意的内存,使用它应该特别的小心,以下涉及的Pointer模式是合理的,不使用这些模式的代码很可能今天或未来不合理.甚至下面的有效模式也带有重要的警告.
运行"go vet"能够帮助发现使用Pointer不是通过这些模式,但是"go vet"沉默不代表代码是合理的.
<div style="padding-left:2.5rem; color:#FF82AB;">
    
    
<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
    转换*T1到Pointer到*T2
    
    </span>
</p>
    前提是T2不大于T1且T1,T2有相同的内存布局，这个转换允许解释一种类型的数据为另一中类型的数据，一个实现是math.Float64bits:
<br/>
<pre><code class="language-go">func Float64bits(f float64) uint64 {
    return *(*uint64)(unsafe.Pointer(&amp;f))
}
</code></pre>
    
<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
    转换为uintptr(但不会转回为Pointer)
    
    </span>
</p>
    转换Pointer到uintptr产生值指向的内存地址,这种uintptr的用法通常是打印它.转换一个uintptr回Pointer通常是不合理的，uintptr是一个整型,不是一个引用,转换一个Pointer到uintptr会创建一个非指针语义的整型值,即使uintptr掌握一些对象的地址,垃圾收集器将不会更新uintptr的值当对象移动了,uintptr也不会使该对象被回收.
    剩余的模式列举了从uintptr到Pointer唯一有效转换.
    
<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
    转换一个Pointer到uintptr或反过来,使用算术
    
    </span>
</p>
    如果p指向一个已分配的对象,则可以通过将对象转换为uintptr并附加偏移值转换回Pointer
<br/>
<pre><code class="language-go">p = unsafe.Pointer(uintptr(p) + offset)
</code></pre>

<p>最多使用该模式的共同点是访问结构体的字段或数组的元素</p>

<pre><code class="language-go">// 等价于 f := unsafe.Pointer(&amp;s.f)
f := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))
// 等价于 e := unsafe.Pointer(&amp;x[i])
e := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;x[0])) + i * unsafe.Sizeof(x[0]))
</code></pre>

<p>通过这种方式地址减或加一个偏移是合理的,使用&amp;^舍入地址也是合理的,通常是为了对齐,在所有的情况下,结果必须继续指向原来对象的内部.<br/>
不像C语言,递进指针超过其原始分配的结尾是不合理的.</p>

<pre><code class="language-go">// 不合理: end超过分配空间的结尾
var s thing
end := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))
// 不合理: end超过分配空间的结尾
b := make([]byte, n)
end := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;b[0])) + uintptr(n))
</code></pre>

<p>请注意两种转换必须出现在相同的表达式,只介于二者的算术：</p>

<pre><code class="language-go">// 不合理: uintptr在转为Pointer前不能储存在变量中
u := uintptr(p)
p = unsafe.Pointer(u + offset)
</code></pre>

<p>注意指针必须是指向已分配的对象,所以它可能是nil</p>

<pre><code class="language-go">// 不合理: 转换nil pointer
u := unsafe.Pointer(nil)
p := unsafe.Pointer(uintptr(u) + offset)
</code></pre>


<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
当调用syscall.Syscall,转换Pointer到uintptr

    </span>
</p>
syscall包Syscall函数直接传递uintptr参数到系统调用,那个取决于调用的细节,当作指针重新解释,系统调用实现不是明确的转换uintptr到指针.如果一个指针参数必须转换为uintptr,转换必须出现在调用表达式本身.
<br/>
<pre><code class="language-go">syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))
</code></pre>

<p>编译器通过安排引用已分配的的对象来处理在汇编中实现的函数的调用参数列表中uintptr转换为Pointer,如果有的话，它不会被移动直到调用完成，即使仅从类型来看,在调用过程中似乎不再需要该对象.
对于编译器认识这种模式,转换必须出现在参数列表中.</p>

<pre><code class="language-go">// 不合理: uintptr不能储存在变量中隐式转换为Pointer之前在系统调用期间
u := uintptr(unsafe.Pointer(p))
syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))
</code></pre>


<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
转换reflect.Value.Pointer或reflect.Value.UnsafeAddr的结果uintptr到Pointer

    </span>
</p>
包reflect.Value的方法reflect.Value.Pointer和reflect.Value.UnsafeAddr返回uintptr而不是Pointer,是为了保证调用将其转化为任意类型首先导入"unsafe"包，这意味着调用的结果是脆弱的,调用者必须在调用后立即转为Pointer在同样的表达式中.
<br/>
<pre><code class="language-go">p := (*int)(unsafe.Pointer(reflect.ValueOf(new (int).Pointer))
</code></pre>

<p>与上述情况一样,储存其结果是不合理的</p>

<pre><code class="language-go">u := reflect.ValueOf(new(int)).Pointer()
p := (*int)(unsafe.Pointer(u))
</code></pre>


<p style="font-size:1em;  margin-bottom:10px; margin-top:10px; display:list-item;">
    <span style="font-size: 0.85em;">
        
转换reflect.SliceHeader或reflect.StringHeader.Data字段到Pointer

    </span>
</p>
在以前的情况下,reflect的数据结构SliceHeader和StringHeader声明的Data字段当作uintptr保证调用者转为任意类型的指针前导入"unsafe"包.这意味着SliceHeader和StringHeader只有当解释实际的切片或字符串值才合理
<br/>
<pre><code class="language-go">var s string
hdr = (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) // 情况1
hdr.Data = uintptr(unsafe.Pointer(p))
hdr.Len = n
</code></pre>

<p>在这种用法中,hdr.Data是一种可选的方法去指出在string header的底层指针而不是uintptr本身.
通常,reflect.SliceHeader,reflect.StringHeader应该只使用*reflect.SliceHeader,*reflect.StringHeader指向实际的切片或字符串,不要当作普通的结构体，程序中不应该声明或分配这些结构体类型的变量.</p>

<pre><code class="language-go">// 不合理: 直接声明的header将不会持有Data的引用
var hdr reflect.SliceHeader
hdr.Data = uintptr(unsafe.Pointer(p))
hdr.Len = n
s := *(*string)(unsafe.Pointer()) // p可能早已遗失
</code></pre>


</div>


</span>

  </div>
  
  <div style="margin-top:0px;" class="pagination">
    <div style="margin-top:10px;" class="pagination__title">
      <span
        class="pagination__title-h">Next Post</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="https://marcoepsilon.github.io/golib/sort/">
          <span class="button__icon">←</span>
          <span class="button__text">Sort</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="https://marcoepsilon.github.io/golib/sync/atomic/">
          <span class="button__text">Atomic</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

<script src="https://utteranc.es/client.js"
        repo="MarcoEpsilon/marcoepsilon.github.io"
        issue-term="og:title"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script>
</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">Marco Epsilon@Copyright</div>
    
  </div>
</footer>
<link rel="stylesheet" type="text/css" href="/assets/prism.css" />
<script src="https://marcoepsilon.github.io/assets/main.js"></script>
<script src="https://marcoepsilon.github.io/assets/prism.js"></script>



<div style="">
    <p style="width:100%; padding-left:25%; color:brown; font-size:23px;">
        我只知道一件事情
    </p>
    <p style="width:100%; padding-left:48%; color:coral; font-size:23px;">我什么都不知道</p>
</div>


  
</div>

</body>
</html>
